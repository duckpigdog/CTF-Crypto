### 爆破还原 p、q（p、q 均较小）

话不多说，直接上题（CTFShow）

![](https://pic1.imgdb.cn/item/6873048958cb8da5c8a5960c.png)

题目代码如下

```python
from Crypto.Util.number import *
from sympy import *
def givemeprime(x):
    ''' x < 502'''
    p = getPrime(x)		# 随机生成一个小素数 p，位数为 x
    print(p)
    while (p).bit_length() <= 512:		# 不断将 p 扩大并取下一个素数
        p = nextprime(p*2**10)
    
    return p 

p = givemeprime(10)		# 初始位数只有 10 位
q = givemeprime(10)
n = p*q
flag=b'?????'
m = bytes_to_long(flag)
e=2**32+1
c=pow(m,e,n)

print('n=',n)
print('c=',c)

'''
n= 9007989895621669259301762739598643626213892494330778168383286295463641223987867033273111296978959160408689408884183780314498828688143466136060628598819311509949865018608092450964012727526450914131409697944090166113416984201622940137239452703698919890772056684013237404520834408811118739546684092365102406400768733
c= 3155015611586304247269005826733691392085437186284673630268852999607965592611252562808748872502491405722341353019602057980123546192900359248245073985988035982837057433789538035295585235536446429172802713235552248615722281314286849930993306403034865999074888279573724168174433746677852218329931104122667029131804586
'''
```

因为 `p` 和 `q` 是通过可控过程生成的（初始为小素数，然后反复乘以 2 的幂再取 nextprime）

我们可以 **穷举初始小素数值**，复现 `givemeprime` 函数，再尝试是否存在一组 `(p, q)` 使得 `p * q == n`

```python
from Crypto.Util.number import *
from sympy import *
from tqdm import tqdm


def givemeprime(p):
    ''' x < 502'''
    # p = getPrime(x)
    while (p).bit_length() <= 512:
        p = nextprime(p * 2 ** 10)

    return p


n = 9007989895621669259301762739598643626213892494330778168383286295463641223987867033273111296978959160408689408884183780314498828688143466136060628598819311509949865018608092450964012727526450914131409697944090166113416984201622940137239452703698919890772056684013237404520834408811118739546684092365102406400768733
c = 3155015611586304247269005826733691392085437186284673630268852999607965592611252562808748872502491405722341353019602057980123546192900359248245073985988035982837057433789538035295585235536446429172802713235552248615722281314286849930993306403034865999074888279573724168174433746677852218329931104122667029131804586
e = 2 ** 32 + 1

primelist = [521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647,
             653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
             809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,
             947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021]

for i in tqdm(range(len(primelist))):
    for j in range(i, len(primelist)):
        p = givemeprime(primelist[i])
        q = givemeprime(primelist[j])
        if p * q == n:
            phi = (p - 1) * (q - 1)
            d = inverse(e, phi)
            m = pow(c, d, n)
            print(long_to_bytes(m))
        else:
            pass
```

