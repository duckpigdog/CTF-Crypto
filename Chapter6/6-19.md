### Lattice 求解模数 n（存在小量 ，提供多个方程组参数）

话不多说，直接上题（青少年 CTF 练习平台）

```python
from Crypto.Util.number import *
from secret import flag
import random
import gmpy2

def generate_Key1(ebits):
    e = [getPrime(ebits) for _ in range(4)]
    return e

def encrypt1(message,e):
    n = gmpy2.next_prime(bytes_to_long(message) << 300)
    m = getPrime(256)
    c = [int(pow(m,e[i],n)) for i in range(len(e))]
    return c

def generate_Key2(nbits):
    p = getPrime(nbits // 2)
    q = getPrime(nbits // 2)
    n = p*q
    e = [random.getrandbits(nbits // 4) for _ in range(3)]
    return n,e

def encrypt2(message,e,n):
    m = bytes_to_long(message)
    c = [int(pow(m,e[i],n)) for i in range(len(e))]
    return c
    
assert flag.startswith(b"DRKCTF{")

flag1 = flag[:len(flag)//2]
flag2 = flag[len(flag)//2:]

ebits = 7
e1 = generate_Key1(ebits)
cipher1 = encrypt1(flag1,e1)
print("e1 =",e1)
print("cipher1 =",cipher1)

nbits = 1024
n,e2 = generate_Key2(nbits)
cipher2 = encrypt2(flag2,e2,n)
print("e2 =",e2)
print("cipher2 =",cipher2)
print("n =",n)

"""
e1 = [109, 71, 109, 73]
cipher1 = [36272047346364825234770733058042613197790911431212158822254782055957208837848605160852567043492625692783344073921185227328379941291979083011033, 13421582077901767047291741873622169312010984740586925881415103229648835151589774736786336965745532072099996467445790339749720696886313635920080, 36272047346364825234770733058042613197790911431212158822254782055957208837848605160852567043492625692783344073921185227328379941291979083011033, 41425183140413487232780768389488969603566343428250573532166425276868000949579663990819005141199597640625439816343697426958648927294289659127871]
e2 = [79572758141493570128961125255246129069540961757778793209698370333142346488381, 80555585862127636800866563977080055603517001358195529410497461746213789997225, 44651921320695090688745333790065512192118202496468714141526113242887125432380]
cipher2 = [58600444300331800249882073146233995912287198739549440714207984476331259754331716531491187240053630185776787152600165426285021284302994699108557023545574315706006132536588848833818758624067461985444940651823107522770906474037882323326792755635934081822967331031854184791299228513024491344725765476710816941057, 16511944800191885973496391252612222059697387587833308714567450121364756390806094606646424594583975159634952911600665271092389815248477961923357683297311169260578508157717777465241680062644118354471550223231057620392252324514411927096940875466794869671163453991620492008856178108060167556176019729800517994337, 80885008609388989196377721090246742575908473911131498982960117640742106565184297197238656375198284856442596226398287448931285735903463892735111244609358611618958293002176923706195402338331128766464276441210238388187625107435781170368017908610916585774514676482124401329575553658828115269495158818527164441546]
n = 93468142044831350317940409833603031534515663349871776634867176846669780024082517910566484997161088199091160371537367121403194814422867749777235397168852158723228851090445429617275680206703935781244466363279841409768649097588586494453125840436600639420286950914680651600232197982546122764845043227394567787283
"""
```

两段 flag，先看第一段，[参考文章脚本](https://tangcuxiaojikuai.xyz/post/39588.html)

```
一个 64 bit的小量 m，依次产生 20 个 128 bit的素数对其进行类似 RSA 的加密，并且给了我们加密指数的列表以及密文的列表

题目满足两个经典条件：存在小量，提供多个方程组参数

这样的问题在很多 crypto 题目中都是用格方法求解的，所以要想到利用格方法（题目的名字虽然说得很明白，但是如果没有，看到这种形式也应该联想到这个方法）

注意到 m 不变，模数 n 也不变，同时加密指数互素，这其实很像共模攻击的情景，只是 n 未知

回想一下在已知模数 n 的情况下共模攻击的实施方法，不难产生下面这个解题思路

取 20 个方程的前三个如下：
```

$$
\begin{aligned}
&out1\ =\ m^{e1}\ (mod\ n)\\\\
&out2\ =\ m^{e2}\ (mod\ n)\\\\
&out3\ =\ m^{e3}\ (mod\ n)\\\\
\end{aligned}
$$

```
（贝组定理）因为 e1，e2 互素，所以存在 a，b，使得：
```

$$
\begin{aligned}
&a\ *\ e1\ +\ b\ *\ e2\ =\ 1
\end{aligned}
$$

```
所以可以得到：
```

$$
\begin{aligned}
&out1^a\ *\ out2^b\ \equiv\ m^{a\ *\ e1\ +\ b\ *\ e2}\ \equiv\ m\ (mod\ n)
\end{aligned}
$$

```
这有什么用呢？我们同样也对 2、3 两式，1、3 两式进行这样的操作，结合上面这个式子能得到三组模等式：
```

$$
\begin{aligned}
&out1^a\ *\ out2^b\ \equiv\ m\ (mod\ n)\ \ \ \ \ \ \ \ \ --1\\\\
&out1^c\ *\ out2^d\ \equiv\ m\ (mod\ n)\ \ \ \ \ \ \ \ \ --2\\\\
&out1^f\ *\ out2^g\ \equiv\ m\ (mod\ n)\ \ \ \ \ \ \ \ \ --3\\\\
\end{aligned}
$$

```
1、2 式作差，2、3 式作差，就得到：
```

$$
\begin{aligned}
&out1^a\ *\ out2^b\ -\ out2^c\ *\ out3^d\ \equiv\ 0\ (mod\ n)\\\\
&out1^f\ *\ out2^g\ -\ out2^c\ *\ out3^d\ \equiv\ 0\ (mod\ n)\\\\
\end{aligned}
$$

```
而现在等式左侧已经没有未知量了（a,b,c,d,f,g 均能够通过扩展欧几里得求出），那么就可以求解他们的 gcd 得到 n

可以说，想到这个思路的时候我为之一振，可惜实际操作的时候这个方法并不能实施，原因也很简单，我们进行的并非模幂运算，而是普通幂运算，并且 a，b 这些指数数量级很大（注意这一点），所以是完全没有办法照这个思路解下去的

这时候我也没有想到怎么利用格，所以进度也停滞了，一卡卡到了晚上

晚上我反复思考的时候，又想到了我刚刚说的那一点，也就是实施不了共模攻击的原因，在于指数的数量级很大，没有办法幂运算

我也突然联想到了 Lattic e中 LLL 算法的重要应用——求解最短向量

那么一切也就说得通了，之所以给 20 个素数作为加密指数，就是可以应用于格密码中，克服刚才共模攻击中两两组合时计算出的 a，b 过大的问题。所以构造格的思路就来了：

因为 20 个指数 e 均互素，所以一定存在 a1，a2，a3…a20，使得
```

$$
\begin{aligned}
&a1\ *\ e1\ +\ a2\ *\ e2\ +\ a3\ *\ e3\ +……a20\ *\ e20\ =\ 1
\end{aligned}
$$

```
所以列出等式：
```

$$
\begin{aligned}
&[a1\ a2\ a3……a20]\ *\ []\ =\ [1\ a1\ a2……a20]
\end{aligned}
$$

```
很明显，这个格符合我们的要求，我们只需要从规约出来的短向量中挑出两组，按理来说，我们只需要类似的进行刚才的共模攻击即可

可是实际操作又遇到了问题，这样规约出来的向量组是这样的：
```

```shell
[ 45 -58   5 -16  12  -7 -27  19   6  14  29 -23 -36  44 -15   1   8  14  -7  11  -9]
[-14 -27  20   6 -40  20 -34  -2 -16  51  35 -23 -51  13   3 -21   0  17  11  -7   1]
[ 15 -36 -21 -13   6  -7  -1 -59 -23  42 -33  15 -30  -4  39  26  41   1  19  10   9]
[-23   4  49 -19  22  -9  24 -20 -20   3 -24   4 -43 -86  40  44  -1  -1  26  25   1]
[ 72  15 -11 -19  26 -31 -56 -25   5  33 -27 -23  12  22  11  -1  21 -17  51 -31   9]
[-35 -73  -8  19 -29  23  -3  20 -10  18  46  29  -9  69 -30   9 -64  13  10 -26   3]
[ 20  46  12  -3  28  -1 -68  15   3 -21 -48 -20  43  54   9  14  -5   0 -44 -24   8]
[ 49   0 -10   0 -46 -47  24  -2  13  10  -3  48  43 -28  -3  53 -15  -6  31 -23  12]
[ -6   0   9  42 -49 -38   8  12   7  39  30 -26  18  37  28 -28   8   2 -67 -21 -15]
[-56  23  22  29  -7 -19  19  -8   6  35   4  -8  22  -2 -44 -69  16  -8  -7 -45  21]
[-21  16  34 -39  36   1  57 -30  -2  -2 -36  -9   9 -27   8 -31 -31  32  12  -2  15]
[ -9  -7   6  40  32 -49 -26 -60  17   0 -13   7  25  57 -19  28  -3 -34  11 -12 -17]
[-30 -13  28 -42   8 -46  56  33 -56 -40 -24   4  10  15  46  50 -13  18 -21  17  16]
[-17 -11  -5  29  14   6 -13   4  42 -69  30   9   3 -37   5   7 -17  50   6  14 -38]
[ 53 -12  16  36   1  38 -52  25 -10 -41  -3 -37   6 -12   1  -4 -25  41   5   1  29]
[ -3   1  36  22   7  -5 -10  15 -10 -27  35 -60 -36   9 -57  33 -21  43  28 -44   8]
[ 32 -26  18  -9  -5  37  -8   2 -36 -28  43  10 -32  37 -24 -70  22 -35  49  -2  31]
[-33  15 -25   1 -40   3  -2 -32  15   9 -20 -27 -27  35  26  -1 -45 -12  45  23  36]
[-17   0  18 -20 -75  -5  55  42  16   8 -45   5 -24 -20 -50 -11   0  27  40  18   8]
[ 11   5  16  37  -2  -6  28  19 -21   5  -8  63  -8 -21  22 -23 -57  13  -5  15 -39]
```

```
第一列并不是我们想要的 1，说明第一列是 1 的向量对比起来长度并不小

再想一下规约的目的，其实很容易就能想通第一列是多少并不重要，重要的是短向量的第一列相同（这一点非常容易想通，没理解的话仔细想想）

而要让他们相同，最有效的办法就是让他们均为 0，想到这一点后，就可以在格的第一列乘上一个大数 K，从而有效的调整一下格，如下：
```

$$
\begin{aligned}
&[a1\ a2\ a3……a20]\ *\ []\ =\ [1\ a1\ a2……a20]
\end{aligned}
$$

```
这样一来，最短向量的第一列就不太可能不是 0 了（因为会对应的扩大K倍，显著地使规约向量变长）

我测试出取 100 左右即可，然后就可以求解最大公约数（此时还需注意两点小问题：一是规约出的短向量有负数，普通幂运算中会变成分数形式，通分至等式右侧即可；二是求得的公约数仍有可能是 k 倍的 n，需要去除一些小因子），最终得到 n
```

```python
e= []
c= []

# step1
L = Matrix(ZZ, 20, 21)
for i in range(20):
    L[i,0] = e[i]*1000
    L[i,i+1] = 1
L = L.LLL()

alist1 = L[0][1:]
k1nl = 1
k1nr = 1
for i in range(20):
    if(alist1[i]<0):
        k1nr *= c[i]**(-alist1[i])
    else:
        k1nl *= c[i]**alist1[i]
k1n = k1nl-k1nr

alist2 = L[1][1:]
k2nl = 1
k2nr = 1
for i in range(20):
    if(alist2[i]<0):
        k2nr *= c[i]**(-alist2[i])
    else:
        k2nl *= c[i]**alist2[i]
k2n = k2nl-k2nr

n = gcd(k1n,k2n)

for i in range(2,10000):
    while(n % i == 0):
        n //= i

# 检查一下 n 的长度是否为 1024 bit
print(len(bin(n)[2:]))
print(n)
```

