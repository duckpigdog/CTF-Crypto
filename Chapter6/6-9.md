### 维纳攻击（e 过大或过小）

话不多说，直接上题（2024 年楚慧杯湖北省网络与数据安全实践能力竞赛）

```python
from Crypto.Util.number import *
from gmpy2 import *
from libnum import *

flag = b'DASCTF{******}'

p = getPrime(512)
q = getPrime(512)
n = p*q
d = getPrime(256)
e = inverse(d, (p-1)*(q-1))
m = s2n(flag)
c = pow(m, e, n)

print('n = ' + str(n))
print('e = ' + str(e))
print('c = ' + str(c))

'''
n = 114566998957451783636756389276471274690612644037126335470456866443567982817002189902938330449132444558501556339080521014838959058380963759366933946623103869574657553262938223064086322963492884606713973124514306815995276393344755433548846003574038937940253826360659447735554684257197194046341849089254659225497
e = 35489734227210930185586918984451799765619374486784192218215354633053183935617953856556709715097294481614236703293033675674496036691242573294182072757562322996800390363453350727372642264982749305833933966045097125311467413670410802534093354414115267442785896373815076066721029449240889291057288090241124904705
c = 60503455347700500866544596012233537789678841391057706123172519773588895502922586197178148979273264437566411675346207472455036341903878112074983509557751805365618433536738111588239911292341288514123006967218545943520736254346030465088445419278775539026233686559207400401082452551955780877227801939191694370380
'''
```

**在 e 过大或过小的情况下，可使用算法从 e 中快速推断出 d 的值，[原文链接](https://www.cnblogs.com/wandervogel/p/16805992.html)**
$$
\begin{aligned}
&\because\ n\ =\ pq\\
&\because\ \varphi(n)\ =\ (q\ -\ 1)(p\ -\ 1)\\
&\therefore\ \varphi(n)\ =\ pq\ -\ (p\ +\ q)\ +\ 1\\
&\therefore\ \varphi(n)\ =\ n\ -\ (p\ +\ q)\ +\ 1\\\\
&\because\ p,q\ are\ very\ large\\
&\therefore\ pq\ >>\ p\ +\ q\\
&\therefore\ \varphi(n)\ \approx\ n\\\\
&\because\ ed\ \equiv\ 1\ mod\ \varphi(n)\\\\
&(This\ ed\ is\ the\ theorem.Don't\ worry\ about\ it)\\\\
&\therefore\ ed\ -\ 1\ =\ k\varphi(n)\\
&\therefore\ \frac{e}{\varphi(n)}\ -\ \frac{1}{d\varphi(n)}\ =\ \frac{k}{d}\\
&\therefore\ \frac{e}{\varphi(n)}\ -\ \frac{k}{d}\ =\ \frac{1}{d\varphi(n)}\\\\
&If\ \ \frac{1}{d\varphi(n)}\ \ is\ very\ small\\
&\frac{e}{\varphi(n)}\ \ and\ \ \frac{k}{d}\ \ are\ very\ close\\\\
&\because\ \varphi(n)\ \approx\ n\\
&\therefore\ \frac{e}{n}\ -\ \frac{k}{d}\ =\ \frac{1}{d\varphi(n)}
\end{aligned}
$$

```python
from RSAwienerHacker import hack_RSA
import libnum


n = 114566998957451783636756389276471274690612644037126335470456866443567982817002189902938330449132444558501556339080521014838959058380963759366933946623103869574657553262938223064086322963492884606713973124514306815995276393344755433548846003574038937940253826360659447735554684257197194046341849089254659225497
e = 35489734227210930185586918984451799765619374486784192218215354633053183935617953856556709715097294481614236703293033675674496036691242573294182072757562322996800390363453350727372642264982749305833933966045097125311467413670410802534093354414115267442785896373815076066721029449240889291057288090241124904705
c = 60503455347700500866544596012233537789678841391057706123172519773588895502922586197178148979273264437566411675346207472455036341903878112074983509557751805365618433536738111588239911292341288514123006967218545943520736254346030465088445419278775539026233686559207400401082452551955780877227801939191694370380

d=hack_RSA(e,n)

print(libnum.n2s(pow(enc ,d ,n)))
```

```python
import gmpy2
from Crypto.Util.number import long_to_bytes


def transform(x, y):
    """
    将分数 x/y 转为连分数形式。
    返回连分数的各项。
    """
    res = []
    
    while y:
		res.append(x // y)
        
		x, y = y, x % y
        
	return res

def continued_fraction(sub_res):
    """
    根据连分数项计算渐进分数的分子和分母。
    sub_res: 连分数的部分序列。
    返回分母和分子。
    """
    numerator, denominator = 1, 0
    
    # 从后往前计算
    for i in reversed(sub_res):
		denominator, numerator = numerator, i * numerator + denominator
        
    return denominator, numerator

def sub_fraction(x, y):
    """
    计算分数 x/y 的所有渐进分数。
    返回每个渐进分数的分母和分子。
    """
    res = transform(x, y)
    
    return [continued_fraction(res[:i]) for i in range(1, len(res))]

def get_pq(a, b, c):
    """
    根据维达定理由 p+q 和 pq 求解 p 和 q。
    a, b, c: 二次方程 ax^2 + bx + c = 0 的系数。
    返回方程的两个根。
    """
    
    # 判别式的平方根
    discriminant = gmpy2.isqrt(b * b - 4 * a * c)
    
    x1 = (-b + discriminant) // (2 * a)
    
    x2 = (-b - discriminant) // (2 * a)
    
    return x1, x2

def wiener_attack(e, n):
    """
    实现维纳攻击，用于破解 RSA 私钥。
    e: 公钥指数。
    n: 公钥模数。
    返回找到的私钥 d，如果攻击无效则返回 None。
    """
    for d, k in sub_fraction(e, n):
		# 跳过无效的渐进分数
         if k == 0:  
             continue

		# 检查 (e*d - 1) 是否可以整除 k
         if (e * d - 1) % k != 0:
             continue

	    # 计算 φ(n)
         phi = (e * d - 1) // k
         
         # 根据 φ(n) 求解 p 和 q
		p, q = get_pq(1, n - phi + 1, n)

		# 验证分解是否正确
		if p * q == n:
			# 确保结果为正数
             p, q = abs(int(p)), abs(int(q))
             
             # 计算私钥 d
             d = gmpy2.invert(e, (p - 1) * (q - 1))
             
             return d

    print("维纳攻击无效")
    
    return None

# 示例数据
if __name__ == "__main__":
	n = 114566998957451783636756389276471274690612644037126335470456866443567982817002189902938330449132444558501556339080521014838959058380963759366933946623103869574657553262938223064086322963492884606713973124514306815995276393344755433548846003574038937940253826360659447735554684257197194046341849089254659225497
	e = 35489734227210930185586918984451799765619374486784192218215354633053183935617953856556709715097294481614236703293033675674496036691242573294182072757562322996800390363453350727372642264982749305833933966045097125311467413670410802534093354414115267442785896373815076066721029449240889291057288090241124904705
	c = 60503455347700500866544596012233537789678841391057706123172519773588895502922586197178148979273264437566411675346207472455036341903878112074983509557751805365618433536738111588239911292341288514123006967218545943520736254346030465088445419278775539026233686559207400401082452551955780877227801939191694370380

    # 执行维纳攻击
    d = wiener_attack(e, n)
    
    if d:
        print("找到私钥 d =", d)
        
        # 解密密文
        print("解密结果:", long_to_bytes(pow(c, d, n)))
```

