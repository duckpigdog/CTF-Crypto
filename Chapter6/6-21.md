### 爆破还原 m（已知 m 范围）

话不多说，直接上题（CTFShow）

![](https://pic1.imgdb.cn/item/6873148e58cb8da5c8a5e7ea.png)

题目代码如下

```python
from Crypto.Util.number import *
from sympy import *

# p 和 q 是 215 位的素数，所以 n = p * q 是一个大整数（430位）
p = getPrime(215)
q = getPrime(215)
n = p*q
e = 73556
flag= b'?????'
m = bytes_to_long(flag)

# nextprime(m) 和 prevprime(m) 输出的是离 m 最近的两个素数
print(nextprime(m))
print(prevprime(m))

# 注意这里的 pow(n,e,m) 看似加密，其实是反常操作
c = pow(n,e,m)
print('n=',n)
print('c=',c)

'''
40913285701005622718863058877533926183158872052161364026817991531
40913285701005622718863058877533926183158872052161364026817991159
n= 1613066479310413323265772296807266781564029043951746766617970255478050198763115133921086056086051610592970427572413404447990142013
c= 34708409030920347254051748353430247487967281837305081753454451319
'''
```

$$
\begin{aligned}
&c\ =\ n^e\ mod\ m
\end{aligned}
$$

```python
from Crypto.Util.number import *
from sympy import *

e = 73556
m_next = 40913285701005622718863058877533926183158872052161364026817991531
m_priv = 40913285701005622718863058877533926183158872052161364026817991159
n = 1613066479310413323265772296807266781564029043951746766617970255478050198763115133921086056086051610592970427572413404447990142013
c = 34708409030920347254051748353430247487967281837305081753454451319

# 暴力穷举 m 在 prevprime 到 nextprime 之间的所有整数（差值很小，几十个）
for i in range(m_priv, m_next):
    if c == pow(n, e, i):
        print(i)
        print(long_to_bytes(i))
```

