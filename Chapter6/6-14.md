### 共模攻击（相同 n）

话不多说，直接上题（攻防世界）

![](https://pic1.imgdb.cn/item/67f798ab88c538a9b5c89dce.png)

先从两个公钥文件中提取公钥信息

```python
from Crypto.PublicKey import RSA

f1 = open("F:\\ChromeCommon\\c2d6e7158d7b4cd6a747774f0bdc5f72\\publickey1.pem","rb").read()
f2 = open("F:\\ChromeCommon\\c2d6e7158d7b4cd6a747774f0bdc5f72\\publickey2.pem","rb").read()
pub1 = RSA.importKey(f1)
pub2 = RSA.importKey(f2)
n1 = pub1.n
e1 = pub1.e
n2 = pub2.n
e2 = pub2.e
print(n1)
print(n2)
print(e1)
print(e2)
```

```
n1 = 13060424286033164731705267935214411273739909173486948413518022752305313862238166593214772698793487761875251030423516993519714215306808677724104692474199215119387725741906071553437840256786220484582884693286140537492541093086953005486704542435188521724013251087887351409946184501295224744819621937322469140771245380081663560150133162692174498642474588168444167533621259824640599530052827878558481036155222733986179487577693360697390152370901746112653758338456083440878726007229307830037808681050302990411238666727608253452573696904083133866093791985565118032742893247076947480766837941319251901579605233916076425572961
n2 = 13060424286033164731705267935214411273739909173486948413518022752305313862238166593214772698793487761875251030423516993519714215306808677724104692474199215119387725741906071553437840256786220484582884693286140537492541093086953005486704542435188521724013251087887351409946184501295224744819621937322469140771245380081663560150133162692174498642474588168444167533621259824640599530052827878558481036155222733986179487577693360697390152370901746112653758338456083440878726007229307830037808681050302990411238666727608253452573696904083133866093791985565118032742893247076947480766837941319251901579605233916076425572961
e1 = 117
e2 = 65537
```

发现 n1 == n2，采用共模攻击

由于 e₁ 和 e₂ 互质，可以找到整数 s 和 t 使得

```
e₁·s + e₂·t = 1
```

如果 s 为正数

```
m ≡ c₁ˢ·c₂ᵗ mod N
```

如果 s 为负数

```shell
# 其中 c₁⁻¹ 是 c₁ 的模逆元
m ≡ (c₁⁻¹)ᵃ·c₂ᵗ mod N
```

```python
from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.PublicKey import RSA
from gmpy2 import gcd, invert


def extended_gcd(a, b):
    """扩展欧几里得算法，返回(g, x, y)使得ax + by = g = gcd(a, b)"""
    if a == 0:
        return b, 0, 1
    else:
        g, y, x = extended_gcd(b % a, a)
        return g, x - (b // a) * y, y


# 读取第一个公钥
with open('pic/publickey1.pem', 'rb') as f:
    pub1 = RSA.importKey(f.read())
n = pub1.n
e1 = pub1.e

# 读取第二个公钥
with open('pic/publickey2.pem', 'rb') as f:
    pub2 = RSA.importKey(f.read())
e2 = pub2.e

# 验证两个公钥使用相同的模数
if pub1.n != pub2.n:
    raise ValueError("两个公钥必须使用相同的模数n")

# 读取密文
with open('pic/cipher1.txt', 'rb') as f:
    c1 = bytes_to_long(f.read())

with open('pic/cipher2.txt', 'rb') as f:
    c2 = bytes_to_long(f.read())

# 计算扩展欧几里得系数
g, s1, s2 = extended_gcd(e1, e2)

# 确保 gcd(e1, e2) = 1
if g != 1:
    raise ValueError("指数 e1 和 e2 必须互质")

# 处理负指数情况
if s1 < 0:
    s1 = -s1
    c1 = invert(c1, n)
elif s2 < 0:
    s2 = -s2
    c2 = invert(c2, n)

# 计算明文: m = (c1^s1 * c2^s2) mod n
m = pow(c1, s1, n) * pow(c2, s2, n) % n

# 输出结果
print("Recovered message:", long_to_bytes(m).decode())
```

