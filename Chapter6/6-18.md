### 离散对数（g^m ≡ c mod p）

话不多说，直接上题（青少年 CTF 练习平台）

![](https://pic1.imgdb.cn/item/6816567758cb8da5c8da0283.png)

下载附件

这实际上是一个**离散对数问题**（Discrete Logarithm Problem, DLP）：给定 `g`, `p`, `c`，求 `m` 使得 `g^m ≡ c mod p`

```python
from Crypto.Util.number import *
from random import *
flag=b'key{xxxxxxx}'
m=bytes_to_long(flag)
p=3006156660704242356836102321001016782090189571028526298055526061772989406357037170723984497344618257575827271367883545096587962708266010793826346841303043716776726799898939374985320242033037
g=3
c=pow(g,m,p)
print(f'c=',c)

#c=2806010417151035336440705514162974780232947158398198485734192667226413654468071006789004899454166950916976496577445879600303537754602011941433695536703970095800594654040421871366147069319806
```

使用 `discrete_log` 函数求解离散对数问题：找到 `m` 使得 `g^m ≡ c mod p`

- `Mod(c, p)` 表示 `c` 在模 `p` 下的剩余类
- `Mod(g, p)` 表示 `g` 在模 `p` 下的剩余类
- `discrete_log` 函数会返回满足 `g^m ≡ c mod p` 的 `m`

```python
# sage
from Crypto.Util.number import *

p = 3006156660704242356836102321001016782090189571028526298055526061772989406357037170723984497344618257575827271367883545096587962708266010793826346841303043716776726799898939374985320242033037
c = 2806010417151035336440705514162974780232947158398198485734192667226413654468071006789004899454166950916976496577445879600303537754602011941433695536703970095800594654040421871366147069319806
g = 3

flag = discrete_log(Mod(c,p),Mod(g,p))
print(long_to_bytes(flag))
```

